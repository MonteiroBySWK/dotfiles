import { useCallback, useEffect, useState } from "react";
import { apiClient } from "@/lib/apiClient";

type ApiError = {
  error: null | { message: null | string };
};
type ApiList<T> = { data: T[]; meta?: any };
type ApiOne<T> = { data: T };

type UseResourceOptions<TData> = {
  // Pega a respsota crua e transforma para o formatdo de estado
  autofetch: boolean;
  transformResponse?: (response: any) => TData;
  idKey?: string;
};

function toMessage(err: unknown) {
  if (typeof err === "string") return err;
  if (err && typeof err === "object") {
    const anyErr = err as any;
    return (
      anyErr?.response?.data?.error ||
      anyErr?.response?.data?.message ||
      anyErr?.message ||
      "Erro inesperado"
    );
  }
  return "Erro inesperado";
}

/*
 * A ideia desse hook é fazer o CRUD por recurso
 * TODO: definir o tipo padrão de retorno de hook, com o adicional de funções
 */

export function useResource<TData>(
  endpoint: string,
  options?: UseResourceOptions<TData>
) {
  const [data, setData] = useState<TData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const load = useCallback(async () => {
    setLoading(true);

    setError(null);
    try {
      const { data } = await apiClient.get<TData>(endpoint);
      setData(data);
      return data;
    } catch (error) {
      setError(toMessage(error));
      throw error;
    } finally {
      setLoading(false);
    }
  }, [endpoint]);

  const create = useCallback(
    async <TCreateInput, TCreateOutput>(
      payload: TCreateInput
    ): Promise<TCreateOutput> => {
      setLoading(true);

      try {
        const res = await apiClient.post<ApiOne<TCreateOutput>>(
          endpoint,
          payload
        );
        const newItem = res.data.data;

        // Atualiza o estado local de forma otimista (se for uma lista)
        setData((currentData) => {
          if (Array.isArray(currentData)) {
            return [newItem, ...currentData] as TData;
          }
          return newItem as TData; // Se não for lista, substitui
        });
        return newItem;
      } catch (error) {
        setError(toMessage(error));
        throw error;
      } finally {
        setLoading(false);
      }
    },
    [endpoint]
  );

  const update = useCallback(
    async (id: string, payload: TData) => {
      setLoading(true);
      try {
        const { data } = await apiClient.put<TData>(
          `${endpoint}/${id}`,
          payload
        );
        setData(data);
        return data;
      } catch (error) {
        setError(toMessage(error));
        throw error;
      } finally {
        setLoading(false);
      }
    },
    [endpoint]
  );

  const remove = useCallback(
    async (id: string) => {
      setLoading(true);

      try {
        const { data } = await apiClient.delete<TData>(`${endpoint}/${id}`);
        setData(data);
        return data;
      } catch (error) {
        setError(toMessage(error));
        throw error;
      } finally {
        setLoading(false);
      }
    },
    [endpoint]
  );

  useEffect(() => {
    if (options?.autofetch) {
      load();
    }
  }, [options?.autofetch, load]);

  const functions = {
    load,
    create,
    update,
    remove,
  };

  return { data, loading, error, functions };
}
