import { useCallback, useEffect, useState, useRef } from "react";
import { apiClient } from "@/lib/apiClient";

// --- Tipos Auxiliares ---

// Erro padrão da API
type ApiError = {
  error?: { message?: string };
};

// Envelope da API para um único recurso
type ApiOne<T> = { data: T };

// Envelope da API para uma lista de recursos
type ApiList<T> = { data: T[]; meta?: any };

// Opções de configuração para o hook
type UseResourceOptions<TData> = {
  // Transforma a resposta crua da API para o formato do estado
  transformResponse?: (response: any) => TData;
  // Chave para identificar itens em uma lista (padrão: 'id')
  idKey?: string;
};

// --- Lógica de Erro ---

function toMessage(err: unknown): string {
  if (err && typeof err === "object") {
    const anyErr = err as any;
    return (
      anyErr?.response?.data?.error ||
      anyErr?.response?.data?.message ||
      anyErr?.message ||
      "Erro inesperado"
    );
  }
  return String(err) || "Erro inesperado";
}

// --- O Hook Refatorado ---

export function useResource<TData>(
  endpoint: string | null, // Permite endpoint nulo para desativar
  options?: UseResourceOptions<TData>
) {
  const [data, setData] = useState<TData | null>(null);
  const [loading, setLoading] = useState(!!endpoint); // Só carrega se houver endpoint
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  // --- Funções de Carga ---

  const load = useCallback(async () => {
    if (!endpoint) {
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    abortRef.current?.abort(); // Cancela requisição anterior
    const controller = new AbortController();
    abortRef.current = controller;

    try {
      const res = await apiClient.get(endpoint, { signal: controller.signal });
      const transformed = options?.transformResponse
        ? options.transformResponse(res.data)
        : res.data;
      setData(transformed);
      return transformed;
    } catch (err: any) {
      if (err.name !== "CanceledError") {
        setError(toMessage(err));
      }
      throw err;
    } finally {
      setLoading(false);
    }
  }, [endpoint, options]);

  // --- Funções de Mutação (CRUD) ---

  const create = useCallback(
    async <TCreateInput, TCreateOutput>(payload: TCreateInput): Promise<TCreateOutput> => {
      if (!endpoint) throw new Error("Endpoint não definido para criação.");
      setLoading(true);
      try {
        const res = await apiClient.post<ApiOne<TCreateOutput>>(endpoint, payload);
        const newItem = res.data.data;

        // Atualiza o estado local de forma otimista (se for uma lista)
        setData((currentData) => {
          if (Array.isArray(currentData)) {
            return [newItem, ...currentData] as TData;
          }
          return newItem as TData; // Se não for lista, substitui
        });
        return newItem;
      } catch (err) {
        setError(toMessage(err));
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [endpoint]
  );

  const update = useCallback(
    async <TUpdateInput, TUpdateOutput extends { [key: string]: any }>(
      id: string,
      payload: TUpdateInput
    ): Promise<TUpdateOutput> => {
      if (!endpoint) throw new Error("Endpoint não definido para atualização.");
      setLoading(true);
      try {
        // A rota pode ser /recurso?id=ID ou /recurso/ID
        const updateEndpoint = endpoint.includes("?") ? `${endpoint.split("?")[0]}?id=${id}` : `${endpoint}/${id}`;
        const res = await apiClient.put<ApiOne<TUpdateOutput>>(updateEndpoint, payload);
        const updatedItem = res.data.data;

        // Atualiza o item na lista local
        setData((currentData) => {
          if (Array.isArray(currentData)) {
            const idKey = options?.idKey ?? "id";
            return currentData.map((item: any) =>
              item[idKey] === id ? updatedItem : item
            ) as TData;
          }
          return updatedItem as TData; // Se não for lista, substitui
        });
        return updatedItem;
      } catch (err) {
        setError(toMessage(err));
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [endpoint, options]
  );

  const remove = useCallback(
    async (id: string): Promise<void> => {
      if (!endpoint) throw new Error("Endpoint não definido para remoção.");
      setLoading(true);
      try {
        const deleteEndpoint = endpoint.includes("?") ? `${endpoint.split("?")[0]}?id=${id}` : `${endpoint}/${id}`;
        await apiClient.delete(deleteEndpoint);

        // Remove o item da lista local
        setData((currentData) => {
          if (Array.isArray(currentData)) {
            const idKey = options?.idKey ?? "id";
            return currentData.filter((item: any) => item[idKey] !== id) as TData;
          }
          return null; // Se não for lista, limpa o estado
        });
      } catch (err) {
        setError(toMessage(err));
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [endpoint, options]
  );

  // --- Efeito de Carga Automática ---

  useEffect(() => {
    if (endpoint) {
      load();
    }
    // Cleanup para abortar a requisição se o componente desmontar
    return () => abortRef.current?.abort();
  }, [endpoint, load]); // Depende do endpoint para refazer a busca se ele mudar

  return {
    data,
    loading,
    error,
    // Funções expostas com tipagem forte
    functions: {
      load,
      create,
      update,
      remove,
      setData, // Expor o setter para manipulação manual se necessário
    },
  };
}
